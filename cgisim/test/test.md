测试主要分为两个部分:

1. 核心代码测试. 由于核心代码使用最频繁且不需要扩展, 可以进行非常细节的测试.
2. 可扩展代码测试. 这主要涉及到角色牌和行动牌两部分. 由于需要考虑扩展, 测试将提供一些接口.

在此基础上又有一些细分, 见下.

## Copy

GameInstance, 所有Zone, 某个Listener实例都需要经过Copy测试, 并仔细地检查其中指针是否正确修改指向.

## Event Execute

这一部分最麻烦. 对于每一个事件都要编写测试代码, 并且, 其测试又有细分:

### Data Consistency

检查事件执行前后的Data变化是否符合预期. 注意, 这里的Data指角色血量, 能量, 骰子数目等"游戏中显式存在的"数据. 不包括监听器为了逻辑运行而另外创建的私有数据.

### Queue Order Check

检查事件队列是否如预期般产生事件.

### Listen Check

检查监听器是否正确响应该事件. 检查监听器的状态是否符合预期.

### 测试桩

检查Event Execute需要提供测试桩(预定义的游戏状态). 我们将先确定一段绝对没有问题的执行序列, 随后在每次测试开始前执行该序列.

考虑到测试需要尽可能覆盖多的场景, 我们也将提供多个测试桩, 其中尽可能地包含足够的监听器以确保各种可能情况都被覆盖.

## Trajectory Check

这实际上是一个集成测试. 将新代码替换掉预先提供的游戏桩的对应部分(例如新卡牌, 新角色). 然后, 游戏引擎根据预先设定好的行动序列(Trajectory)进行执行, 通常, 该序列会刻意地触发新代码的所有可能分支. 

## Stochasticity Check

对于预期随机的内容, 需要检查相应的Determination是否可以正常工作(case, set).
